## 一、数据结构和算法概念

### 数据结构的概念

#### 什么是数据结构

数据结构是计算机存储和组织数据的方式。数据结构是指互相之间存在一种或多种特定关系的数据元素集合。

数据结构用于在内存中存储数据

#### 常见的数据结构

- 线性表
  - 数组
  - 链表
  - 栈
  - 队列
- 散列表
  - hash
  - 位图
- 树
  - 二叉树
  - 多路树
  - 堆
- 图
  - 有向图
  - 无向图
  - 带权图

### 算法的概念

#### 什么是算法

算法是指解决方案的完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制

算法是一种解决特定问题的思路

#### 常见的算法

- 排序
  - 冒泡
  - 快速
  - 插入
  - 并归
  - 计数排序
  - 选择排序
  - 堆排序
  - 桶排序
- 其他
  - LRU
  - LFU
  - hash算法
  - 一致性hash
- 算法思维
  - 递归
  - 回溯
  - 分治
  - 贪心
  - 动态规划

### 算法复杂度

数据结构的本质是快和省。代码执行的效率是非常重要的度量。

#### 时间复杂度

时间复杂度也称为渐进时间复杂度。

计算时间复杂度的技巧：

- 计算循环执行最多的代码
- 总复杂度=量级最大的复杂度

#### 空间复杂度

空间复杂度也称为渐进空间复杂度，表示算法的存储空间与数据规模的增长关系

> 在实际开发中，我们更加关注代码的时间复杂度，而用于执行效率的提高



## 二、数据结构与算法基础

### 1、线性表

线性表就是数据排成像一条线一样的结构，数据只有前后两个方向

#### 1)、数组

数组（array）是有限个相同类型的变量所组成的有序集合，数组中的每个变量被称为元素。

数组是最为简单、最为常用的数据结构。

数组的下标从0开始。

数组用一组连续的内存空间来存储一组具有相同类型的数据。

数组可以根据下标随机访问数据。

```java
public class ArrayDemo1 {

    int[] nums = new int[8];

    public ArrayDemo1(){
        nums[0] = 3;
        nums[1] = 1;
        nums[2] = 2;
        nums[3] = 3;
        nums[4] = 4;
        nums[5] = 5;
        nums[6] = 6;
        nums[7] = 7;
    }

    public int get(int index){
        if(index >= nums.length || index < 0)
            throw new ArrayIndexOutOfBoundsException();
        return nums[index];
    }

    public void update(int index, int val){
        if(index >= nums.length || index < 0)
            throw new ArrayIndexOutOfBoundsException();
        nums[index] = val;
    }

    public void insertTail(int val){
        nums[6] = val;
    }

    public void insertMid(int index,int val){
        if(index >= nums.length || index < 0)
            throw new ArrayIndexOutOfBoundsException();
        for(int i = nums.length - 1; i >= index ; i--){
            if(nums[i] != 0){
                nums[i + 1] = nums[i];
            }
        }
        nums[index] = val;
    }

    public void resize(){
        int[] newNums = new int[2 * nums.length];
        System.arraycopy(nums,0,newNums,0,nums.length);
        nums = newNums;
    }

    public void insertOutOfBounds(int index,int val){
        resize();
        nums[index] = val;
    }

    public void deleteMid(int index){
        for (;index < nums.length - 1; index++) {
            nums[index] = nums[index + 1];
        }
        nums[nums.length - 1] = 0;
    }

    public void disPlay(){
        for (int i = 0; i < nums.length; i++) {
            System.out.println(nums[i]);
        }
    }

    @Override
    public String toString() {
        return Arrays.toString(nums);
    }

    public static void main(String[] args) {
        ArrayDemo1 arrayDemo1 = new ArrayDemo1();
        arrayDemo1.disPlay();
        arrayDemo1.deleteMid(7);
        arrayDemo1.disPlay();
    }

}
```

##### 总结：

​	**时间复杂度：**

​		读取和更新数据都是随机访问O1

​		插入和删除的操作，无论是涉及到扩容还是元素移动，时间复杂度都是O(n)

​	**优缺点：**

​		优点：数组拥有非常高效的随机访问能力，通过下标访问时间复杂度O1

​		缺点：插入和删除元素，由于数组元素紧密的存储在内存中，插入和删除都会导致大量元素被迫移动，影响效率。

​					申请的空间必须是连续的，即使有空间也可能因为没有足够的连续的空间二创建失败

​					如果超出范围，需要申请新的空间，原空间就浪费了

#### 2)、链表

链表是一种在物理上非连续、非顺序的数据结构，由若干节点（node）组成。

链表中的数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的节点组成，节点可以在运行时动态生成。每个节点包括两部分：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域。

常见的链表包括：单链表、双向链表、循环链表

- 单链表：单向链表的每个节点包含两部分，一部分是存放数据的变量data，另一部分是指向下一个节点的指针next

```java
Node{
  int data;
  Node next;
}
```

- 双向链表：双向链表中每个节点除了拥有data和next指针，还拥有指向前置节点的prev指针

```java
Node{
  int data;
  Node prev;
  Node next;
}
```

- 循环链表：链表的为节点指向头节点形成一个环，称为循环链表

![](D:\mdspace\md-img\循环链表结构图.PNG)

**存储原理**

​	数组在内存中的存储方式是连续存储，链表在内存中存储的方式是随机存储。

​	链表的每一个节点分布在内存的不同位置，依靠next指针关联起来。这样可以灵活有效的利用零散的碎片空间。

​	链表的第一个节点被称为头节点，没有任何节点的next指针指向它，或者它的前置节点为空。

​	头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。

​	链表的最后一个节点被称为尾节点，它指向的next为空。

**操作**

- 查找节点

在查找元素时，链表只能从头结点开始向后一个一个节点逐一查找。

- 更新节点

找到要更新的节点，把旧数据替换为新数据。

- 插入节点

尾部插入：将最后一个节点的next指向新插入的节点即可

头部插入：将新节点的next指针指向原先的头结点，然后将新节点变为链表的头部节点

中间插入：新节点的next指针指向插入位置的节点，插入位置前置节点的next指针指向新节点

> 只要内存空间允许，能够插入链表的元素是没有上限的，不需要向数组那样考虑扩容的问题

- 删除节点：

尾部删除：把倒数第二个节点的next指针指向空即可

头部删除：把链表头节点设为原先头节点的next指针即可

中间删除：把要删除节点的前置节点的next指针，指向要删除节点的next指针指向的节点

```java
/**
 * 单链表
 */
public class SingleLinkedList {

    private Node head = new Node(0, "");

    /**
     * 添加节点从头部插入
     */
    public void addFirst(Node node){
        node.next = head;
        head = node;
    }

    /**
     * 从尾部添加节点
     */
    public void addLast(Node node){
        Node tmp = head;
        while (true){
            if (tmp.next == null){
                break;
            }
            tmp = tmp.next;
        }
        tmp.next = node;
    }

    /**
     * 添加节点
     */
    public void addNode(Node node){
        addLast(node);
    }

    /**
     * 基于id精确插入
     */
    public void addNodeByOrder(Node node){
        Node tmp = head;
        while (true){
            //到尾节点
            if(tmp.next == null){
                break;
            }
            //找到匹配的
            if(tmp.next.id >= node.id){
                break;
            }
            tmp = tmp.next;
        }
        node.next = tmp.next;
        tmp.next = node;
    }

    public void disPlay(){
        if(null == head.next){
            System.out.println("链表为空");
            return;
        }
        Node tmp =  head;
        while (tmp != null){
            System.out.println(tmp);
            tmp = tmp.next;
        }
    }

    static class Node {
        int id;
        String name;
        Node next;
        Node(int id,String name){
            this.id = id;
            this.name = name;
        }

        @Override
        public String toString() {
            return "Node{" +
                    "id=" + id +
                    ", name='" + name + '\'' +
                    ", next=" + next +
                    '}';
        }
    }
}
```

```java
/**
 * 双向链表
 */
public class BilateralLinkedList {

    private Node head;
    private Node tail;
    private int size;

    public void disPlay(){
        System.out.println("size："+size);
        System.out.println("head："+head);
        System.out.println("tail："+tail);
    }

    //头部添加
    public void addFirst(String data){
        Node node = new Node(data);
        if(null == head){
            head = node;
            tail = node;
        }else {
            node.next = head;
            head.prev = node;
            head = node;
        }
        size++;
    }

    //在尾部进行添加
    public void addLast(String data){
        Node node = new Node(data);
        if(null == tail){
            tail = node;
            head = node;
        }else {
            node.prev = tail;
            tail.next = node;
            tail = node;
        }
        size++;
    }

    public void add(String data){
        addLast(data);
    }

    public void remove(String data){
        if(size == 0){
            return;
        }
        Node tmp = head;
        while (tmp != null){
            if (tmp.data.equals(data)){
                if(tmp.prev == null){
                    removeFirst();
                    return;
                }else if(tmp.next == null){
                    removeLast();
                    return;
                }else {
                    //删除中间节点
                    Node prev = tmp.prev;
                    Node next = tmp.next;
                    prev.next = next;
                    next.prev = prev;
                }
            }
            tmp = tmp.next;
        }
        size--;
    }

    public void removeFirst(){
        if(size == 0){
            return;
        }
        if(size == 1){
            head = null;
            tail = null;
            return;
        }
        //删除头结点
        Node next = head.next;
        head = next;
        next.prev = null;
        size--;
    }

    public void removeLast(){
        if(size == 0){
            return;
        }
        if(size == 1){
            head = null;
            tail = null;
            return;
        }
        //删除尾节点
        Node prev = tail.prev;
        prev.next = null;
        tail = prev;
        size--;
    }

    public Boolean contains(String data){
        if (size != 0){
            Node tmp = head;
            while (tmp != null){
                if(tmp.data == data){
                    return true;
                }
                tmp = tmp.next;
            }
        }
        return false;
    }

    public void addAll(Collection<String> collection){
        if(null == collection){
            return;
        }
        Node tmp = tail;
        for (String s : collection) {
            tmp.next = new Node(s);
            tmp = tmp.next;
            size++;
        }
        tail = tmp;
    }
}
```

##### 总结：

​	**时间复杂度**

​		查找节点：O(n)

​		插入节点：O(1)

​		指定位置插入节点：O(n)

​		删除节点：O(n)

​	**优缺点**

​		优势：头部尾部操作速度快，插入、删除效率高、省空间（节点不需要占用连续的内存空间）

​		劣势：查询效率低，不能随机访问

##### 数组与链表的对比：

数据结构没有绝对的好与坏，数组和链表各有千秋。

<img src="D:\mdspace\md-img\链表和数组的时间复杂度比较图.PNG" style="zoom:75%;" />

数组的优势在于能够快速定位元素，对于读操作比较多、写操作比较少的场景来说，数组更适合一些。

链表的优势在于能后灵活的进行插入和删除的操作，如果需要在尾部频繁的插入、删除元素，用链表更合适一些。

数组和链表是线性数据存储的物理存储结构：即顺序存储和链式存储

#### 3)、栈

栈和队列都属于线性数据的逻辑存储结构

<img src="D:\mdspace\md-img\数据结构分析表格.PNG" style="zoom:75%;" />

##### 概念

栈（stack）是一种线性数据结构，栈中的元素只能先进后出（First In Last Out，简称 FILO）

最早进入的元素存放的位置叫做栈低（bottom），最后进入的元素存放的位置叫做栈顶（top）

##### 存储原理

栈既可以通过数据来实现，也可以通过链表来实现

栈的数组实现如下：

<img src="D:\mdspace\md-img\栈的数组实现.PNG" style="zoom:75%;" />

数组实现的栈也叫做顺序栈或静态栈

栈的链表实现如下：

![](D:\mdspace\md-img\栈的链表实现.PNG)

链表实现的栈也叫做链式栈或动态栈

##### 操作

- 入栈（压栈）

  入栈操作（push）就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将成为新的栈顶

  ![](D:\mdspace\md-img\入栈操作.png)

- 出栈

  出栈操作（pop）就是把元素从栈中弹出，只有栈顶的元素才允许出栈，出栈元素的前一个元素会成为新的栈顶

  ![](D:\mdspace\md-img\出栈操作.png)

```java
/**
 * 数组实现栈操作
 */
public class ArrayStack {

    private int size;

    private int[] container;

    public ArrayStack(int capacity){
        container = new int[capacity];
    }

    //压栈
    public void push(int data){
        if(size == container.length){
            resize();//扩容
        }
        //考虑扩容操作
        container[size] = data;
        size++;
    }

    //弹栈
    public int pop(){
        size--;
        int popData = container[size];
        return popData;
    }

    //扩容操作
    public void resize(){
        int newCapacity = 2 * size;
        int[] newContainer = new int[newCapacity];
        System.arraycopy(container,0,newContainer,0,container.length);
        container = newContainer;
    }

    public void disPlay(){
        System.out.println("Stack：" + Arrays.toString(container));
        System.out.println("size："+ size);
    }
```

```java
/**
 * 链表实现栈
 */
public class LinkedStack {

    private Node head;

    //压栈
    public void push(String data){
        Node node = new Node(data);
        if (null == head){
            head = node;
        }else {
            node.next = head;
            head = node;
        }
    }

    //弹栈
    public String pop(){
        if(head == null){
            System.out.println("栈中已无数据");
            return null;
        }else {
            String data = head.data;
            head = head.next;
            return data;
        }
    }

    public void disPlay(){
        Node tmp = head;
        while (tmp != null){
            System.out.print(tmp.data+"-");
            tmp = tmp.next;
        }
    }
    
}
```

##### 时间复杂度

入栈和出栈的时间复杂度都是O(1)

支持动态扩容的顺序栈

使用数组实现栈，当数组空间不够时，需要重新申请内存，将原来数组中数据复制到新数组中，此时的入栈操作时间复杂度为O(n)

#### 4)、队列

##### 概念

队列（queue）是一种线性数据结构，对了中的元素只能先进先出（First In First Out，简称 FIFO）

队列的出口端叫做队头（front），队列的入口端叫做队尾（rear）

##### 存储原理

队列这种数据结构既可以通过数组来实现，也可以通过链表来实现

- 数组实现

  <img src="D:\workspace\dataStructure\resource\md-img\队列的数组实现.PNG" style="zoom:75%;" />

  用数组实现时，为了入队操作的方便，把队尾规定为最后入队元素的下一个位置

  用数组实现的队列叫做顺序队列

- 链表实现

  ![](D:\workspace\dataStructure\resource\md-img\链表实现队列.PNG)

  用链表实现的队列叫做链式队列

##### 操作

- 入队

  入队就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾

<img src="D:\workspace\dataStructure\resource\md-img\队列入队操作.PNG" style="zoom:75%;" />

- 出队

  出队操作就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素会成为新的队头

<img src="D:\workspace\dataStructure\resource\md-img\队列出队操作.PNG" style="zoom:75%;" />

```java
/**
 * 使用数组来实现队列
 */
public class ArrayQueue {

    private int[] container;
    private int size;

    public ArrayQueue(int capacity){
        container = new int[capacity];
        size = 0;
    }

    /**
     * 元素入队操作
     */
    public void offer(int data){
        if(size == container.length){
            resize();
        }
        container[size] = data;
        size++;
    }

    /**
     * 检索并移除此队列的头部，如果此队列为空，则返回null 。
     * 返回：此队列的头部，如果此队列为空，则为null
     */
    public int poll(){
        int result = 0;
        if(size > 0){
            result = container[0];
            //将后续的元素数据向前移动
            for (int i = 0; i < container.length - 1; i++) {
                container[i] = container[i + 1];
            }
            container[container.length -1] = 0;
            size --;
        }
        return result;
    }

    //扩容方法
    public void resize(){
        int[] newContainer = new int[2 * container.length];
        System.arraycopy(container,0,newContainer,0,container.length);
        container = newContainer;
    }

    public void disPlay(){
        System.out.println("size：" + size);
        System.out.println(Arrays.toString(container));
    }

}
```

```java
/**
 * 链表实现队列
 */
public class LinkedQueue {

    private Node head;

    private Node tail;

    //入队操作
    public void offer(String data){
        Node node = new Node(data);
        if(null == head){
            head = node;
            tail = node;
        }else {
            tail.next = node;
            tail = node;
        }
    }

    //出队操作，将队头出队
    public String poll(){
        if(null == head){
            return null;
        }
        Node tmp = head;
		//设置新队头
        head = head.next;
        //将旧队头的下一个节点指向null 让gc进行回收
        tmp.next = null;
        return tmp.data;
    }

    public void disPlay(){
        System.out.println(head);
    }

}
```

##### 时间复杂度

入队和出队都是O(1)

### 2、散列表

##### 概念

散列表也叫哈希表（hash table），这种数据结构提供了键（key）和值（value）的映射关系。只要给出一个key，就可以高效查找到它所匹配的Value，时间复杂度接近O(1)

##### 存储原理

散列表在本质上也是一个**数组**

散列表的key以字符串类型为主

通过hash函数把key和数组的下标进行转换

作用是把任意长度的输入通过散列算法转换成固定类型、固定长度的散列值

HashMap源码计算数据存入的下标位置（此处基于JDK1.8分析）：

```java
/**
 * 对key进行扰动hash --> hash(key)
 * 计算出key.hashCode后，将散列的较高的16位与低位16位进行异或操作
 * 增加key.hashCode二次幂掩码下位区16位的随机性，为了增加后续元素
 * 存入计算下标的随机性，避免hash碰撞
 */
static final int hash(Object key) {
   int h;
   return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

/**
 * 计算下标位置代码如下：
 * n -> n = tab.length n表示当前HashMap内部Node[]数组的长度
 * 因为hashMap的数组容量一定是2的幂，这里使用 n-1 获取一个奇数
 * (n - 1) & hash hash为key的扰动hash值，这里进行位于操作来获取下标，
 * 比1.8之前的%（取余操作效率更高），这里位于使用到的主要是扰动hash值
 * 的下位区的二进制码（解释了之前为什么要增加key.hashCode的随机性），
 * 这样在计算下标时，计算出来的下标随机更高，这么做也是为了避免hash碰撞
 */
index = (n - 1) & hash
```

key.hashCode()这是最简单的hash值计算方式

还有很多hash函数：CRC16、CRC32、siphash、murmurHash、time33等

这些Hash值计算方式为固定方式，也称为传统Hash，在数组长度固定时，可以快速检索，但当数组长度变化时再根据key进行检索时将出现问题

所以传统Hash计算方式虽然使用起来很简单，但是不利于扩展，如果需要保证扩展性可以使用**一致性Hash法**

##### 操作

- 写操作

  写操作就是在散列表中插入新的键值对

  第一步，计算key.hashCode，并计算出键值对应存入的数组下标位置

  第二步，如果计算出来的数组下标位置没有元素，就把键值对填充到此处

- Hash冲突（碰撞）

  由于数组的长度是有限的，当插入的Node越来越多时，如果出现不同的key计算出来的下标位置相同，这种情况就叫做**Hash冲突**。

  解决Hash冲突主要有两种方法：

  **开放寻址法**

  开放寻址法的原理是当一个key通过哈希函数获得对应的数组下标已被占用时，就寻找下一个没有存储元素的空位置

  > 在Java中，ThreadLocal所使用的就是开放寻址法

  **链表法**

  数组的每一个元素不仅是一个Node对象，还是一个单链表的头节点。每一个Node节点通过next指针指向链表中的下一个Node节点。如果产生了Hash冲突，在不考虑覆盖值的情况下，在链表的尾部添加节点。

HashMap中的Node节点结构如下（基于JDK1.8分析）：

```java
class Node<K,V> implements Map.Entry<K,V> {
     final int hash;//key的扰动hash值
     final K key;
     V value;
     Node<K,V> next;//作为单链表的next指针
}
```

​		链表取值，根据key计算出下标位置如果是单链表结构，需要遍历链表获取key匹配的节点，返回节点的值。

- 读操作

  读操作就是通过给定的key，在散列表中查找对应的Value

  第一步，通过基于key.hashCode计算出数组下标

  第二步，找到数组下标对应的元素，如果key不匹配，遍历单链表进行key匹配，找到匹配的节点，返回节点中保存的value

- Hash表扩容

  散列表是基于数组实现的，所以散列表需要扩容

  当经过多次元素插入，散列表达到一定的饱和度时，Key映射位置发生冲突的概率会逐渐提高。这样一来，大量的元素拥挤在相同的数组下标位置，形成很长的链表，对后续的插入操作和查询操作性能都有很大影响。

  影响扩容的因素有两个：

  Capacity：HashMap的当前长度，默认16（1 << 4）

  ```java
  static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
  ```

  LoadFactor：HashMap的负载因子，默认是0.75f，当 **HashMap.Size >= Capacity*LoadFactor** 时需要进行扩容。

  ```java
  static final float DEFAULT_LOAD_FACTOR = 0.75f;
  ```

  扩容的步骤：

  ​	1.创建一个新的Node空数组，长度是原来数组的2倍

  ​	2.reHash操作，遍历原来的Node数组，把所有的Node重新Hash到新数组中

  















































